<!DOCTYPE HTML>
<html>

<head>
    <title>ESP32PP v0.30</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            padding: 10px;
            line-height: 1.6;
        }

        pre {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.9rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background-color: #1e1e1e;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        }

        header h1 {
            font-size: 1.8rem;
            color: #bb86fc;
        }

        header .setupicon a {
            font-size: 2rem;
            color: #03dac6;
            text-decoration: none;
            display: inline-block;
            transition: transform 0.3s ease, color 0.3s ease;
        }

        header .setupicon a:hover {
            color: #018786;
            transform: rotate(45deg);
        }

        h1,
        h2 {
            font-weight: bold;
        }

        main {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        #mainscreen {
            display: flex;
            flex-wrap: wrap;
            flex: 2;
        }

        .devremote {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background-color: #1e1e1e;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            min-width: 350px;
        }

        .screen-container {
            text-align: center;
            flex: 2;
            padding: 20px;
            background-color: #1e1e1e;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        }

        #screen {
            border: 1px solid #bb86fc;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(187, 134, 252, 0.5);
        }

        .btnControl {
            box-shadow: none;
            border-radius: 50%;
            text-align: center;
            justify-content: center;
            align-items: center;
            padding: 0;
            margin: 5px;
            overflow: hidden;
            width: 65px;
            height: 65px;
            display: inline;
            color: white;
            transition: transform 0.2s, background-color 0.3s;
        }

        .btnLine {
            display: block;
            text-align: center;
        }

        button:disabled {
            background-color: #3a3a3a;
            color: #7a7a7a;
            cursor: not-allowed;
            box-shadow: none;
        }

        .greenbtn {
            background-color: #00a96f;
        }

        .greenbtn:not(:disabled):hover {
            background-color: #388e3c;
        }

        .redbtn {
            background-color: #ef4c53;
        }

        .redbtn:not(:disabled):hover {
            background-color: #d32f2f;
        }

        .bluebtn {
            background-color: #00b3f0;
        }

        .bluebtn:not(:disabled):hover {
            background-color: #1976d2;
        }


        #espAppContainer,
        #devdatas,
        #wsDisplay,
        #manualcommand {
            display: flex;
            flex-direction: column;
            background-color: #1e1e1e;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            gap: 20px;
        }

        .dev-data-rows {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }

        #btnManualSend,
        #btnOpenFlmgr,
        #bntRefresh {
            background-color: #2196f3;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #btnManualSend:hover,
        #btnOpenFlmgr:hover,
        #bntRefresh:hover {
            background-color: #1976d2;
        }

        #btnManualSend:disabled,
        #btnOpenFlmgr:disabled,
        #bntRefresh:disabled,
        #btnGps:disabled {
            background-color: #3a3a3a;
            color: #7a7a7a;
            cursor: not-allowed;
        }

        #manualcommand input[type="text"] {
            padding: 10px;
            border: 1px solid #03dac6;
            border-radius: 5px;
            background-color: #121212;
            color: white;
            width: 80%;
        }

        #manualcommand input[type="text"]:focus {
            outline: none;
            border-color: #018786;
        }

        #btnGps {
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        #filemanager button {
            padding: 4px 6px;
            border-radius: 3px;
            cursor: pointer;
        }


        #fileList {
            min-width: 300px;
        }

        #fileProgress {
            display: none;
        }

        #wsd_title {
            display: inline;
        }

        #wsDisplay {
            min-height: 252px;
        }

        #espAppStartList button,
        #btnEspAppStop {
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
        }

        .espAppCnt button {
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <header>
        <h1>ESP32 PP v0.30</h1>
        <div class="status">
            <div id="connState">WS Connecting...</div>
            <div id="connStatePP">PP not connected to ESP</div>
        </div>
        <div class="setupicon"><a href="setup.html">&#9881;</a></div>
    </header>
    <main>
        <section id="mainscreen">
            <div class="screen-container">
                <canvas id="screen" height="320" width="240">No gui support</canvas>
                <div class="screen-options">
                    <input type="checkbox" id="screenRefresh" name="autoScreenRefresh" checked />
                    <label for="screenRefresh">Auto refresh</label><br />
                    <button id="bntRefresh" class="greenbtn uicontrols" onclick="refreshScreen()">Refresh</button>
                </div>
            </div>
            <div class="devremote">
                <div class="btnLine">
                    <div class="btnControl">&nbsp;</div>
                    <button id="btnCtrUp" class="btnControl greenbtn uicontrols" onclick="sendButton(4)">&uarr;</button>
                    <div class="btnControl">&nbsp;</div>
                </div>
                <div class="btnLine">
                    <button id="btnCtrLeft" class="btnControl greenbtn uicontrols"
                        onclick="sendButton(2)">&larr;</button>
                    <button id="btnCtrEnter" class="btnControl bluebtn uicontrols" onclick="sendButton(5)">O</button>
                    <button id="btnCtrRight" class="btnControl greenbtn uicontrols"
                        onclick="sendButton(1)">&rarr;</button>
                </div>
                <div class="btnLine">
                    <button id="btnCtrRotLeft" class="btnControl greenbtn uicontrols"
                        onclick="sendButton(8)">&#8635;</button>
                    <button id="btnCtrDown" class="btnControl greenbtn uicontrols"
                        onclick="sendButton(3)">&darr;</button>
                    <button id="btnCtrRotRight" class="btnControl greenbtn uicontrols"
                        onclick="sendButton(7)">&#8634;</button>
                </div>
                <div class="btnLine">
                    <button id="btnCtrDFU" class="btnControl redbtn uicontrols" onclick="sendButton(6)">DFU</button>
                    <button id="btnCtrRST" class="btnControl redbtn uicontrols" onclick="sendReboot()">RESET</button>
                </div>
            </div>
        </section>
        <section id="filemanager" style="display: none;">
            Path: <span id="filePath">/</span><br />
            <select id="fileList" size=20>
            </select>
            <br />
            <button class="uicontrols" onclick="cwdup(); return false;">Cd ..</button>
            <button class="uicontrols" onclick="ls(); return false;">Refresh</button>
            <button class="uicontrols" onclick="fileDelete(); return false;">Delete</button><br />
            <input class="uicontrols" type="file" id="fileUpfile" />
            <button class="uicontrols" onclick="fileUpload(); return false;">Upload</button><br />
            <button class="uicontrols" onclick="fileDownload(); return false;">Download</button>
            <button class="uicontrols" onclick="fileFlash(); return false;">Flash</button><br /><br />
            <button class="uicontrols" onclick="fileManClose(); return false;">Close file manager</button><br />
            <progress id="fileProgress" value="0" max="100"></progress>

        </section>

        <section id="devdatas">
            <div class="dev-data-rows">
                <div id="devTemp">Temp: ?</div>
                <div id="devGpsLat">Lat: ?</div>
                <div id="devGpsLon">Lon: ?</div>
                <div id="devHead">Heading: ?</div>
                <div id="devGpsSats">Sats: ?</div>
            </div>
            <div>
                Gps debug: <input type="checkbox" id="gpsDebugChk" class="" onchange="gpsDebugChkChanged(this)" /></div>
            <div id="devGPSDebugRes" style="display: none;"></div>

            <div>
                <button onclick="getGPSPosition();" id="btnGps" class="uicontrols">&#128204;</button>
                <button class="uicontrols" id="btnOpenFlmgr" onclick="fileManOpen(); return false;">Open file
                    manager</button>
            </div>
        </section>
        <section id="wsDisplay">
            <h2>WSD-<div id="wsd_title">not loaded yet</div>
            </h2>

            <div id="wsd_maintext"></div>
        </section>
        <section id="espAppContainer">
            <h2>Esp's App</h2>
            <div><button id="btnEspAppStop" style="display: none;" onclick="sendMessage('#$##$$$00\r\n')">Stop</button>
            </div>
            <div id="espAppStartList" style="display: none;">
                <button onclick="sendMessage('#$##$$$01\r\n')">Wifi SSID spam</button>
                <!-- <button onclick="sendMessage('#$##$$$02\r\n')">Wifi list</button>
                <button onclick="sendMessage('#$##$$$03\r\n')">Wifi probe sniffer</button> -->
            </div>
            <div id="espAppDT1" class="espAppCnt" style="display: none;">
                <h3>Wifi spam</h3>
                <button onclick="sendMessage('#$$#$$$10\r\n')">Standby mode</button>
                <button onclick="sendMessage('#$$#$$$11\r\n')">Random mode</button>
                <button onclick="sendMessage('#$$#$$$12\r\n')">Rick Roll mode</button>
                <button onclick="sendMessage('#$$#$$$13\r\n')">Emoji spam mode</button>
            </div>
        </section>

        <section id="manualcommand">
            <h2>Manual Commands</h2>
            <input type="text" id="manualtxt" />
            <button onclick="manualSend()" id="btnManualSend" class="uicontrols">Send</button>
            <pre id="log"></pre>
        </section>
    </main>
    <script>
        const PROMPT = "ch> ";
        var respWaiting = PROMPT;
        var respCallBack = null;
        var enableSend = false; //keep track if sending is allowed or not
        var gateway = `ws://${window.location.hostname}/ws`;
        if (window.location.protocol === "file:") gateway = `ws://192.168.4.1/ws`;
        var websocket;
        var respLines = []; //resp lines list.
        var respLinestp = []; //resp lines list to parse
        var respLastLine = ""; //last line of resp
        var gpsQueryInProgress = false;
        var receivedChunks = []; //for file down
        var expectedFileSize = 0; //file size
        var resolveSt = null; //if wait for the resolve during send
        var screensupdState = 0; //0-not that cmd, 1 = begin, 2 = second line
        var gotbytes = 0; //for file download progress
        window.addEventListener('load', onLoad);

        function enadisaControls(ena) {
            enableSend = ena;
            var elementsToDisable = document.querySelectorAll('.uicontrols');
            elementsToDisable.forEach(function (element) {
                element.disabled = !ena;
            });
        }

        function setProgress(prog) {
            var pb = document.getElementById("fileProgress");
            if (prog < 0) //hide
            {
                pb.style.display = "none";
            }
            else {
                pb.style.display = "block";
                pb.value = prog;
            }
        }

        function log(data) {
            if (!data.endsWith("\r\n")) { data += "\r\n"; }
            console.log(data);
            var logc = document.getElementById("log")
            logc.innerHTML = data + logc.innerHTML;
            if (logc.innerHTML.length > 1024) {
                logc.innerHTML = logc.innerHTML.substring(0, 1024);
            }
        }

        //esp app specific functions
        function refreshUIForCurrentApp(app) {
            document.getElementById("btnEspAppStop").style.display = (app == 0) ? "none" : "inline-block";
            document.getElementById("espAppStartList").style.display = (app == 0) ? "block" : "none";
            document.getElementById("espAppDT1").style.display = (app == 1) ? "block" : "none";
        }


        //others
        function initWebSocket() {
            log("WS Connecting...");
            websocket = new WebSocket(gateway);
            websocket.onopen = onOpen;
            websocket.onclose = onClose;
            websocket.onmessage = onMessage;
            websocket.error = onError;
        }

        function onError(event) {
            log("WS error");
        }

        function onOpen(event) {
            log("WS Connected");
            document.getElementById("connState").innerHTML = "WS Connected.";
            sendMessage("#$##$$#GETUSBSTATE\r\n");
            //sendMessage("#$##$$$99\r\n"); //get currenltly running esp app //todo call on all loaded
        }

        function onClose(event) {
            enadisaControls(false);
            log("WS Closed");
            document.getElementById("connState").innerHTML = "WS Reconnecting...";
            setTimeout(initWebSocket, 1000);
        }
        function gotSensor(data) {
            document.getElementById("devTemp").innerHTML = "Temp: " + data.env.temp + " &#8451;";
            if (data.gps.lat != 200 && data.gps.lon != 200) {
                document.getElementById("devGpsLat").innerHTML = "Lat: " + data.gps.lat;
                document.getElementById("devGpsLon").innerHTML = "Lon: " + data.gps.lon;
            }
            else {
                document.getElementById("devGpsLat").innerHTML = "Lat: ? ";
                document.getElementById("devGpsLon").innerHTML = "Lon: ? ";
            }
            var headstr = "Heading: " + data.ori.head + "&#176;";
            if (data.ori.tilt < 400) headstr += " Tilt: " + data.ori.tilt + "&#176;";
            document.getElementById("devHead").innerHTML = headstr;
            document.getElementById("devGpsSats").innerHTML = "Sats: " + data.gps.siu + "/" + data.gps.siv;
        }

        //when all the required data in
        function onDataArrived() {
            log("Command executed");
            enadisaControls(true);
            try {
                respLinestp = respLines;
                respLines = [];
                var tmpCb = respCallBack;
                respCallBack = null;
                if (tmpCb) tmpCb();
                if (resolveSt != null) {
                    var tmp = resolveSt;
                    resolveSt = null;
                    tmp();
                }
            } catch (err) { console.log(err); }
        }

        function escapeHTML(unsafe) {
            return unsafe.replace(
                /[\u0000-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u00FF]/g,
                c => '&#' + ('000' + c.charCodeAt(0)).slice(-4) + ';'
            )
        }
        //one line received
        function onMessageLine(msg) {
            try {
                console.log(msg);
                if (msg.startsWith("#$##$$#")) {
                    if (msg == "#$##$$#USB_DC\r\n") {
                        log("PP Disconnected");
                        enadisaControls(false);
                        const canvas = document.getElementById("screen");
                        const ctx = canvas.getContext("2d");
                        ctx.fillStyle = "#000";
                        ctx.fillRect(0, 0, 240, 320);
                        document.getElementById("connStatePP").innerHTML = "PP NOT connected to ESP";
                        return false;
                    }
                    if (msg == "#$##$$#I2C_DC\r\n") {
                        log("PP Disconnected (I2C)");
                        enadisaControls(false);
                        const canvas = document.getElementById("screen");
                        const ctx = canvas.getContext("2d");
                        ctx.fillStyle = "#000";
                        ctx.fillRect(0, 0, 240, 320);
                        document.getElementById("connStatePP").innerHTML = "PP NOT connected to ESP";
                        return false;
                    }
                    if (msg == "#$##$$#USB_CC\r\n") {
                        log("PP Connected");
                        enadisaControls(true);
                        fileManClose();
                        document.getElementById("connStatePP").innerHTML = "PP connected to ESP";
                        autoScreenRefresh();
                        return false;
                    }
                    if (msg == "#$##$$#I2C_CC\r\n") {
                        log("PP Connected (I2C)");
                        enadisaControls(true);
                        fileManClose();
                        document.getElementById("connStatePP").innerHTML = "PP connected to ESP (I2C)";
                        autoScreenRefresh();
                        return false;
                    }
                    if (msg.startsWith("#$##$$#GOTSENS")) {
                        var jsStr = msg.substring(14);
                        var gpsdata = JSON.parse(jsStr);
                        gotSensor(gpsdata);
                        return false;
                    }
                    if (msg.startsWith("#$##$$#GOTIRRX")) {
                        //{"protocol":1,"data":33438150,"len":34
                        var jsStr = msg.substring(14);
                        var irdata = JSON.parse(jsStr);
                        var protocol = "UNK";
                        if (irdata.protocol == 1) protocol = "NEC";
                        if (irdata.protocol == 2) protocol = "NECEXT";
                        if (irdata.protocol == 3) protocol = "SONY";
                        if (irdata.protocol == 4) protocol = "SAM";
                        if (irdata.protocol == 5) protocol = "RC5";
                        log("IR RX: " + protocol + " " + irdata.data.toString(16) + " " + irdata.len + " bits");
                        return false;
                    }
                    if (msg.startsWith("#$##$$#GOTGPSDEBUG")) {
                        document.getElementById("devGPSDebugRes").innerHTML = msg.substring(19);
                        return false;
                    }
                    if (msg.startsWith("#$##$$#GOTDISPLAYTITLE")) {
                        document.getElementById("wsd_title").innerHTML = escapeHTML(msg.substring(22));
                        return false;
                    }
                    if (msg.startsWith("#$##$$#GOTDISPLAYMAIN")) {
                        let tmp = escapeHTML(msg.substring(21));
                        tmp = tmp.replaceAll("&#0092;n", "<br/>");
                        document.getElementById("wsd_maintext").innerHTML = tmp;
                        return false;
                    }
                }
                if (msg.startsWith("#$##$$$")) {
                    let tmp = msg.substring(7);
                    log("Got ESP app: " + tmp);
                    let appid = parseInt(tmp);
                    refreshUIForCurrentApp(appid);
                    return false;
                }
                if (screensupdState == 1) {
                    screensupdState = 2;
                    log("Screen data arriving...");
                }
                if (screensupdState >= 0) return true;
                if (expectedFileSize > 0) return true;
                log("> " + msg + "\r\n");
            } catch (err) { console.log(err); };
            return true;
        }
        //any ws message
        async function onMessage(event) {
            try {
                var str = await event.data.text();//String(event.data);
                for (let i = 0; i < str.length; i++) {
                    var resetline = false;
                    respLastLine += str[i];
                    if (str[i] == "\n") {
                        respLines.push(respLastLine);
                        onMessageLine(respLastLine);
                        resetline = true;
                        //need a download progressbar?
                        if (expectedFileSize > 0) {
                            var gotlines = respLines.length - 1;
                            gotbytes = 0;
                            for (let j = 0; j < gotlines; j++) {
                                var byteperline = (respLines[j].length - 2) / 2;
                                gotbytes += byteperline;
                            }
                        }
                    }
                    if (respLastLine.endsWith(respWaiting) || respLastLine.startsWith(respWaiting)) {
                        onDataArrived();
                    }
                    if (respLastLine.endsWith(PROMPT)) {//this counts too
                        onMessageLine(respLastLine);
                        resetline = true;
                    }
                    if (resetline) respLastLine = "";
                }
            }
            catch (err) {
                console.log(err);
            }
        }

        function enterCritical() {
            sendMessage("#$##$$#DISABLEESPASYNC\r\n");
        }

        function exitCritical() {
            sendMessage("#$##$$#ENABLEESPASYNC\r\n");
        }

        function sendMessage(data) {
            try {
                respLines = [];
                log("< " + data);
                screensupdState = 0;
                if (data.startsWith("screenframe")) screensupdState = 1;
                websocket.send(data);
            } catch (err) { console.log(err); }
        }

        async function sendAndWait(data) {
            return new Promise((resolve) => {
                try {
                    resolveSt = resolve;
                    sendMessage(data);
                } catch (err) { console.log(err); }
            });
        }

        function sendBinaryMessage(data) {
            try {
                log("< BIN " + data.length)
                websocket.send(data);
            } catch (err) { console.log(err); }
        }


        function gotCursorPosition(canvas, event) {
            if (!enableSend) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor(event.clientX - rect.left);
            const y = Math.floor(event.clientY - rect.top);
            sendTouch(x, y);
        }

        function onLoad(event) {
            initWebSocket();
            enadisaControls(false);
            var canvas = document.getElementById("screen");
            canvas.addEventListener('mousedown', function (e) {
                gotCursorPosition(canvas, e);
            })
        }
        async function screenUpdated() {
            const canvas = document.getElementById("screen");
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, 320, 480);
            let y = -1;
            if (respLinestp.length < 300 && respLinestp[respLinestp.length - 1].startsWith("ChibiOS")) {
                await sendAndWait("");
                if (respLinestp.length < 300) {
                    refreshScreen();
                    return;
                }
            }
            let portarf = false;
            for (let i = 0; i < respLinestp.length; i++) {
                if (respLinestp[i].length < 230) continue;
                y++;
                for (let x = 0; x < respLinestp[i].length; x++) {
                    if (x > 320) break;
                    try {
                        let by = respLinestp[i].charCodeAt(x) - 32;
                        let r = ((by >> 4) & 3) << 6;
                        let g = ((by >> 2) & 3) << 6;
                        let b = (by & 3) << 6;
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx?.fillRect(x, y, 1, 1);
                    }
                    catch (err) { console.log(err); }
                    if (x > 300) {
                        portarf = true;
                    }
                }
                if (y == 0 && portarf) {
                    //this is portarf, so resize the screen
                    canvas.height = 480;
                    canvas.width = 320;
                }
            }

        }

        function sendGps(lat, lon, alt) {
            const altitude = alt !== null && alt !== undefined ? alt : 0;
            var tosend = "gotgps " + String(lat) + " " + String(lon) + " " + String(altitude) + "\r\n";
            respWaiting = PROMPT;
            enadisaControls(false);
            sendMessage(tosend);
        }
        async function sendButton(btn) {
            var tosend = "button " + String(btn) + "\r\n";
            respWaiting = PROMPT;
            enadisaControls(false);
            await sendAndWait(tosend);
            autoScreenRefresh();
        }
        async function sendTouch(x, y) {
            var tosend = "touch " + String(x) + " " + String(y) + "\r\n";
            respWaiting = PROMPT;
            enadisaControls(false);
            await sendAndWait(tosend);
            autoScreenRefresh();
        }
        function sendReboot() {
            var tosend = "reboot\r\n";
            respWaiting = PROMPT;
            enadisaControls(false);
            sendMessage(tosend);
        }
        function autoScreenRefresh() {
            var checkbox = document.getElementById("screenRefresh");
            if (checkbox.checked) {
                refreshScreen();
            }
        }
        function refreshScreen() {
            var tosend = "screenframeshort\r\n";
            respWaiting = PROMPT;
            enadisaControls(false);
            respCallBack = screenUpdated;
            sendMessage(tosend);
        }

        function fileSelected() {
            var selectElement = document.getElementById("fileList");
            var selectedOption = selectElement.options[selectElement.selectedIndex];
            var selectedValue = selectedOption.value;
            if (selectedValue == "..") {
                cwdup();
                return;
            }
            if (selectedValue.endsWith("/")) {
                var path = document.getElementById("filePath").innerHTML;
                path += selectedValue;
                document.getElementById("filePath").innerHTML = path;
                ls();
                return;
            }
            else {
                if (!selectedValue.endsWith(".tar") && !selectedValue.endsWith(".bin")) {
                    if (confirm("Download can take some time, start it?")) fileDownload();
                }
                else {
                    fileFlash();
                }
            }
        }

        async function fileDownload() {
            var path = document.getElementById("filePath").innerHTML;
            if (!path.endsWith("/") && path.length > 1) path = path + "/";
            var selectElement = document.getElementById("fileList");
            var selectedOption = selectElement.options[selectElement.selectedIndex];
            var selectedValue = selectedOption.value;
            if (selectedValue.endsWith("/")) {
                log("Can't download a folder yet.");
            }
            else {
                receivedChunks = [];
                expectedFileSize = 0;
                var target = path + selectedValue;
                enadisaControls(false);
                var tosend = "fclose\r\n";
                respWaiting = PROMPT;
                await sendAndWait(tosend);
                enadisaControls(false);
                tosend = "filesize " + target + "\r\n";
                respWaiting = PROMPT;
                await sendAndWait(tosend);
                if (respLinestp.length <= 2) {
                    log("Error downloading file");
                    return;
                }
                if (!respLinestp[2].startsWith("ok")) {
                    log("File read error");
                    return;
                }
                expectedFileSize = parseInt(respLinestp[1].trim());
                enadisaControls(false);
                tosend = "fopen " + target + "\r\n";
                respWaiting = PROMPT;
                await sendAndWait(tosend);
                //file opened
                enadisaControls(false);
                enterCritical();
                var tosend = "fseek 0\r\n";
                respWaiting = PROMPT;
                await sendAndWait(tosend);
                enadisaControls(false);
                gotbytes = 0;
                let gotbytesAll = 0;
                let concatenatedHexData = "";
                while (gotbytesAll < expectedFileSize) {
                    //var tosend = "fread " + expectedFileSize.toString() + "\r\n";
                    var tosend = "fread 512\r\n";
                    respWaiting = PROMPT;//?!
                    await sendAndWait(tosend);
                    var beflen = concatenatedHexData.length;
                    concatenatedHexData += respLinestp.slice(1, -1).join('').replace(/\r\n/g, "");
                    if (respLinestp[respLinestp.length - 1] != "ok\r\n") {
                        concatenatedHexData += respLinestp[respLinestp.length - 1].replace(/\r\n/g, "");
                    }
                    respLinestp = [];//save ram
                    gotbytesAll = concatenatedHexData.length / 2;
                    var progress = gotbytesAll / expectedFileSize * 100;
                    if (progress > 100) progress = 100;
                    setProgress(progress);
                    //await new Promise(r => setTimeout(r, 150));
                    if (concatenatedHexData.length == beflen) {
                        break;
                    }
                }
                //check if i downloaded it or not
                if (gotbytesAll < expectedFileSize) {
                    log("Error downloading file. I2C or Wifi issue?! Got " + gotbytes.toString() + " instead of " + expectedFileSize.toString());
                    return;
                }
                expectedFileSize = 0;
                setProgress(-1);
                const bytes = new Uint8Array(concatenatedHexData.length / 2);
                for (let i = 0; i < concatenatedHexData.length; i += 2) {
                    bytes[i / 2] = parseInt(concatenatedHexData.substr(i, 2), 16);
                }
                const link = document.createElement('a');
                link.href = URL.createObjectURL(new Blob([bytes]));
                link.download = selectedValue;
                link.click();
                enadisaControls(false);
                var tosend = "fclose\r\n";
                respWaiting = PROMPT;
                await sendAndWait(tosend);
                exitCritical();
            }
        }

        async function fileDelete() {
            var path = document.getElementById("filePath").innerHTML;
            if (!path.endsWith("/") && path.length > 1) path = path + "/";
            var selectElement = document.getElementById("fileList");
            var selectedOption = selectElement.options[selectElement.selectedIndex];
            var selectedValue = selectedOption.value;
            if (selectedValue.length < 1 || selectedValue == "..") {
                log("Please select a valid file.")
                return;
            }
            if (selectedValue.endsWith("/")) {
                log("Can't delete a folder yet.");
            }
            else {
                var target = path + selectedValue;
                if (confirm("Really delete this file? " + target)) {
                    var tosend = "unlink " + target + "\r\n";
                    respWaiting = PROMPT;
                    enadisaControls(false);
                    await sendAndWait(tosend);
                    ls();
                }
            }
        }

        async function fileUpload() {
            var fileInput = document.getElementById('fileUpfile');
            if (fileInput.files.length > 0) {
                var fileName = fileInput.files[0].name;
                var file = fileInput.files[0];
                var path = document.getElementById("filePath").innerHTML;
                if (!path.endsWith("/") && path.length > 1) path = path + "/";
                var target = path + fileName;
                var tosend = "unlink " + target + "\r\n";
                respWaiting = PROMPT;
                enadisaControls(false);
                await sendAndWait(tosend);
                enadisaControls(false);
                tosend = "fopen " + target + "\r\n";
                respWaiting = PROMPT;
                enadisaControls(false);
                await sendAndWait(tosend);
                enadisaControls(false);
                tosend = "fwb " + file.size.toString() + "\r";
                respWaiting = "send ";
                enadisaControls(false);
                await sendAndWait(tosend);
                respWaiting = PROMPT;
                var chunkSize = 300;
                var offset = 0;
                enadisaControls(false);
                var reader = new FileReader();
                reader.onload = async function () {
                    if (websocket.readyState === WebSocket.OPEN) {
                        setProgress(offset / file.size * 100);
                        websocket.send(reader.result);
                        offset += reader.result.byteLength;
                        if (offset < file.size) {
                            readSlice(offset);
                        } else {
                            //SENT ALL
                            log("File sent");
                            setProgress(-1);
                            respWaiting = PROMPT;
                            await sendAndWait(""); //wait for send end prompt
                            tosend = "fclose\r\n";
                            enadisaControls(false);
                            await sendAndWait(tosend);
                            enadisaControls(false);
                            ls();
                        }
                    }
                };
                async function readSlice(start) {
                    await new Promise(r => setTimeout(r, 1));
                    var slice = file.slice(start, start + chunkSize);
                    reader.readAsArrayBuffer(slice);
                }
                readSlice(0);

            } else {
                log('Please select a file to upload.');
            }
        }

        function fileFlash() {
            var path = document.getElementById("filePath").innerHTML;
            if (!path.endsWith("/") && path.length > 1) path = path + "/";
            var selectElement = document.getElementById("fileList");
            var selectedOption = selectElement.options[selectElement.selectedIndex];
            var selectedValue = selectedOption.value;
            var target = path + selectedValue;
            if (!selectedValue.endsWith(".tar") && !selectedValue.endsWith(".bin")) {
                log("Can flash only TAR and BIN files. Selected: " + target);
            }
            else {
                if (confirm("Really flash " + target + " ?")) {
                    var tosend = "flash " + target + "\r\n";
                    respWaiting = PROMPT; //not needed, since pp will reconnect
                    enadisaControls(false);
                    sendMessage(tosend);
                }
            }
        }


        function filesLsArrived() {
            var fl = document.getElementById("fileList");
            fl.innerHTML = "";
            var path = document.getElementById("filePath").innerHTML;
            if (path != "/") {
                fl.innerHTML += "<option ondblclick='fileSelected(); return false;' value='..'>..</option>";
            }
            for (let i = 0; i < respLinestp.length; i++) {
                var line = respLinestp[i].trim();
                if (line.startsWith("ls ")) continue;
                if (line.startsWith("#$##$$#")) continue;
                if (line.startsWith(PROMPT)) continue;
                fl.innerHTML += "<option ondblclick='fileSelected(); return false;' value='" + line + "'>" + line + "</option>";
            }
        }

        function ls() {
            var path = document.getElementById("filePath").innerHTML;
            if (path.endsWith("/") && path.length > 1) path = path.substring(0, path.length - 1);
            var tosend = "ls " + path + "\r\n";
            respWaiting = PROMPT;
            enadisaControls(false);
            respCallBack = filesLsArrived;
            sendMessage(tosend);
        }

        function cwdup() {
            var path = document.getElementById("filePath").innerHTML;
            if (path.length > 1) {
                path = path.replace(/\/+$/, '');
                let lastSlashIndex = path.lastIndexOf('/');
                if (lastSlashIndex >= 0) {
                    path = path.substring(0, lastSlashIndex + 1);
                }
            }
            document.getElementById("filePath").innerHTML = path;
            ls();
        }

        function manualSend() {
            var tosend = document.getElementById("manualtxt").value;
            if (!tosend.endsWith("\r\n")) { tosend += "\r\n"; }
            respWaiting = PROMPT;
            enadisaControls(false);
            sendMessage(tosend);
            document.getElementById("manualtxt").value = "";
        }

        function getGPSPosition() {
            if (gpsQueryInProgress) return;
            if (navigator.geolocation) {
                gpsQueryInProgress = true;
                navigator.geolocation.getCurrentPosition(
                    function (position) {
                        gpsQueryInProgress = false;
                        document.getElementById("devGpsLat").innerHTML = "Lat: " + position.coords.latitude;
                        document.getElementById("devGpsLon").innerHTML = "Lon: " + position.coords.longitude;
                        sendGps(position.coords.latitude, position.coords.longitude, position.coords.altitude)
                    },
                    function (error) {
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                log("User denied the request for Geolocation.");
                                break;
                            case error.POSITION_UNAVAILABLE:
                                log("Location information is unavailable.");
                                break;
                            case error.TIMEOUT:
                                log("The request to get user location timed out.");
                                break;
                            default:
                                log("An unknown error occurred.");
                                break;
                        }
                        gpsQueryInProgress = false;
                    }
                );
            } else {
                log("Geolocation is not supported by this browser.");
            }
        }

        function fileManClose() {
            document.getElementById("filemanager").style.display = "none";
            document.getElementById("mainscreen").style.display = "flex";
            document.getElementById("devdatas").style.display = "flex";
        }
        function fileManOpen() {
            document.getElementById("filemanager").style.display = "block";
            document.getElementById("mainscreen").style.display = "none";
            document.getElementById("devdatas").style.display = "none";
            ls();
        }

        function gpsDebugChkChanged(chk) {
            if (chk.checked) {
                sendMessage("#$##$$#GPSDEBUGON\r\n");
                document.getElementById("devGPSDebugRes").style.display = "block";
            }
            else {
                sendMessage("#$##$$#GPSDEBUGOFF\r\n");
                document.getElementById("devGPSDebugRes").style.display = "none";
            }
        }

    </script>
</body>

</html>